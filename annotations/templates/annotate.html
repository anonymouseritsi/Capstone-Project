<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Line Annotation Tool with Length/Width Labels</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <style>
    canvas { border: 1px solid black; }
    #controls { margin-top: 10px; }
    .annotation-form {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      display: none;
    }
    .annotation-form textarea {
      width: 100%;
      min-height: 100px;
      margin: 10px 0;
      padding: 8px;
    }
    .annotation-form button {
      margin: 5px;
      padding: 8px 16px;
      cursor: pointer;
    }
    .note-label {
      background: rgba(255, 255, 255, 0.9);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      max-width: 200px;
      word-wrap: break-word;
    }
  </style>
</head>
<body>
  <h1>Line Annotation Tool with Length/Width Labels</h1>
  <canvas id="canvas" width="800" height="600"></canvas>

  <div id="controls">
    <button onclick="setAnnotationMode('length')">Length Annotation</button>
    <button onclick="setAnnotationMode('width')">Width Annotation</button>
    <button onclick="saveAnnotations()">Save Annotations</button>
    <button id="undoAnnotation">Undo</button>
  </div>

  <!-- Add annotation note form -->
  <div id="annotationForm" class="annotation-form">
    <h3>Add Note to Annotation</h3>
    <textarea id="annotationNote" placeholder="Enter your note here..."></textarea>
    <button onclick="saveNote()">Save Note</button>
    <button onclick="cancelNote()">Cancel</button>
  </div>

  <script>
    let canvas = new fabric.Canvas('canvas');
    let undoStack = [];
    let currentMode = null; // Current annotation mode (length or width)
    let currentAnnotation = null; // Store the current annotation being created

    // Load the latest uploaded image from API
    fetch('/api/images/')
      .then(response => response.json())
      .then(images => {
        if (images.length > 0) {
          let latestImage = images[images.length - 1];
          let imageUrl = latestImage.image.startsWith("/")
            ? window.location.origin + latestImage.image
            : latestImage.image;

          fabric.Image.fromURL(imageUrl, function(img) {
            let maxWidth = 800;
            let maxHeight = 600;
            let scale = Math.min(maxWidth / img.width, maxHeight / img.height);
            img.scale(scale);
            img.set({
              selectable: false,
              evented: false,
              hasControls: false,
              lockMovementX: true,
              lockMovementY: true,
              lockScalingX: true,
              lockScalingY: true,
              lockRotation: true
            });

            canvas.setWidth(img.width);
            canvas.setHeight(img.height);
            canvas.add(img);
            canvas.sendToBack(img);
          });
        } else {
          alert("No images found. Please upload an image first.");
        }
      })
      .catch(error => console.error("Error fetching images:", error));

    // Function to set annotation mode (Length or Width)
    function setAnnotationMode(mode) {
      currentMode = mode;
      alert(`${mode.charAt(0).toUpperCase() + mode.slice(1)} Annotation mode activated.`);
    }

    // Track all line annotations for undo
    canvas.on('object:added', function(e) {
      if (e.target.type === 'line') {
        undoStack.push({
          line: e.target,
          label: e.target.label,
          noteLabel: e.target.noteLabel
        });
      }
    });

    // Undo functionality
    document.getElementById('undoAnnotation').addEventListener('click', function () {
      if (undoStack.length > 0) {
        let last = undoStack.pop();
        canvas.remove(last.line);
        canvas.remove(last.label);
        if (last.noteLabel) {
          canvas.remove(last.noteLabel);
        }
        canvas.renderAll();
      }
    });

    // Drawing a line for the annotation
    let isDrawing = false;
    let startPoint, endPoint, line, text;

    canvas.on('mouse:down', function (event) {
      if (!currentMode) {
        alert("Please select an annotation mode first!");
        return;
      }

      isDrawing = true;
      let pointer = canvas.getPointer(event.e);
      startPoint = pointer;

      // Create an empty line
      line = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
        left: pointer.x,
        top: pointer.y,
        stroke: 'red',
        strokeWidth: 2,
        selectable: false,
      });

      // Create an empty label for length/width
      text = new fabric.Text("", {
        left: pointer.x,
        top: pointer.y - 20,
        fontSize: 14,
        fill: 'black',
        backgroundColor: 'white'
      });

      canvas.add(line);
      canvas.add(text);

      // Add label reference to the line object for easy removal later
      line.label = text;
    });

    canvas.on('mouse:move', function (event) {
      if (!isDrawing || !line) return;
      let pointer = canvas.getPointer(event.e);
      endPoint = pointer;

      // Draw the line based on selected annotation mode
      line.set({ 
        x2: pointer.x, 
        y2: pointer.y 
      });

      // Update label text to reflect length/width
      let length = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));

      if (currentMode === 'length') {
        text.set({
          text: `Length: ${length.toFixed(2)} px`,
          left: (startPoint.x + endPoint.x) / 2,
          top: (startPoint.y + endPoint.y) / 2 - 20
        });
      } else if (currentMode === 'width') {
        let width = Math.abs(endPoint.x - startPoint.x);
        text.set({
          text: `Width: ${width.toFixed(2)} px`,
          left: (startPoint.x + endPoint.x) / 2,
          top: (startPoint.y + endPoint.y) / 2 - 20
        });
      }

      canvas.renderAll();
    });

    canvas.on('mouse:up', function () {
      if (!isDrawing || !line) return;
      isDrawing = false;

      // Store the current annotation and show the note form
      currentAnnotation = {
        line: line,
        label: text
      };
      
      // Show the annotation form
      document.getElementById('annotationForm').style.display = 'block';
    });

    // Function to save the note
    function saveNote() {
      const note = document.getElementById('annotationNote').value.trim();
      if (note && currentAnnotation) {
        // Create note label
        const noteLabel = new fabric.Text(note, {
          left: (currentAnnotation.line.x1 + currentAnnotation.line.x2) / 2,
          top: (currentAnnotation.line.y1 + currentAnnotation.line.y2) / 2 + 20,
          fontSize: 12,
          fill: 'black',
          backgroundColor: 'rgba(255, 255, 255, 0.9)',
          padding: 5,
          selectable: false
        });

        canvas.add(noteLabel);
        currentAnnotation.line.noteLabel = noteLabel;
        
        // Update the undo stack with the note
        if (undoStack.length > 0) {
          undoStack[undoStack.length - 1].noteLabel = noteLabel;
        }
      }
      
      // Clear and hide the form
      closeNoteForm();
    }

    // Function to cancel note addition
    function cancelNote() {
      closeNoteForm();
    }

    // Helper function to close the note form
    function closeNoteForm() {
      document.getElementById('annotationNote').value = '';
      document.getElementById('annotationForm').style.display = 'none';
      currentAnnotation = null;
    }

    // Save the annotations
    function saveAnnotations() {
      window.alert("Annotation saved!")
      const imageData = canvas.toDataURL({
        format: 'jpeg',
        quality: 0.8
      });

      const formData = new FormData();
      formData.append('imageData', imageData);

      fetch("{% url 'patient_manager:save_annotation' patient.slug %}", {
        method: 'POST',
        headers: {
          'X-CSRFToken': '{{ csrf_token }}'
        },
        body: formData
      })
      .then(response => {
        if (response.redirected) {
          window.location.href = response.url;
        }
      })
      .catch(error => console.error("Error saving annotation:", error));
    }
  </script>
</body>
</html>
